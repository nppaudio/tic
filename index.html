<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TIC - Timbre Impression Chart v21 (Dynamic Layout)</title>
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
  <style>
    /* --- 基本スタイル --- */
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: #eee;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      color: #333;
      padding-bottom: 40px;
    }

    #container {
      width: 100%;
      max-width: 720px;
      background: #fff;
      display: flex;
      flex-direction: column;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }

    /* --- キャンバスエリア --- */
    #canvas-wrapper {
      position: -webkit-sticky;
      position: sticky;
      top: 0;
      background: #eee;
      z-index: 100;
      padding: 0;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      width: 100%;
      overflow: hidden;
      display: flex;
      justify-content: center;
    }

    canvas {
      display: block;
      background: #ccc;
      max-width: 100%;
      height: auto; 
    }

    /* --- コントロールエリア --- */
    #controls {
      padding: 15px;
      box-sizing: border-box;
      background: #fff;
    }

    .input-group {
      margin-bottom: 15px;
    }
    input[type="text"], select {
      width: 100%;
      padding: 10px;
      box-sizing: border-box;
      border-radius: 4px;
      border: 1px solid #ccc;
      margin-bottom: 10px;
      font-size: 16px;
    }
    #textInput { font-weight: bold; }
    #reviewerInput { font-weight: normal; }

    /* 共通ボックススタイル */
    .control-box {
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      background: #fafafa;
      padding: 15px;
      margin-bottom: 20px;
    }

    /* 全体設定、Stage設定など */
    .simple-grid {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 10px;
    }
    .simple-grid label {
      flex: 1 1 30%; /* 3列表示 */
      font-size: 0.9em;
      display: flex;
      flex-direction: column;
      font-weight: bold;
      text-align: center;
      align-items: center;
      min-width: 80px;
    }

    /* --- パラメータセクション --- */
    .param-section {
      margin-bottom: 25px;
      border: 1px solid #ccc;
      border-radius: 8px;
      background: #fff;
      overflow: hidden;
    }
    
    .param-header {
      background: #f0f0f0;
      padding: 10px 15px;
      font-weight: bold;
      border-bottom: 1px solid #ddd;
      font-size: 1em;
      color: #333;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .slider-grid {
      display: grid;
      /* スマホデフォルト: 縦1列 */
      grid-template-columns: 1fr;
      gap: 15px;
      padding: 20px 10px;
    }

    .band-cell {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      width: 100%;
    }

    .band-label {
      font-size: 0.9em;
      font-weight: bold;
      color: #555;
      margin-bottom: 2px;
    }

    /* スライダー本体のスタイル */
    input[type=range] {
      -webkit-appearance: none;
      height: 6px;
      border-radius: 4px;
      background: #ddd;
      cursor: pointer;
      margin: 10px 0;
      width: 75%;
      display: block;
      margin-left: auto;
      margin-right: auto;
    }

    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      background: #333;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid #fff;
      box-shadow: 0 1px 4px rgba(0,0,0,0.4);
    }

    .value {
      font-weight: bold;
      text-align: center;
      font-size: 1.1em; 
      color: #0078d7;
      display: block;
      width: 100%;
      margin-top: 2px;
    }

    /* --- PC / タブレット (600px以上) --- */
    @media (min-width: 600px) {
      .slider-grid {
        grid-template-columns: repeat(7, 1fr);
        gap: 5px;
        padding: 10px;
      }
      
      .band-label {
        font-size: 0.75em;
        height: 2.4em;
        display: flex;
        align-items: center;
        justify-content: center;
        line-height: 1.1;
      }

      input[type=range] {
        width: 100%;
        margin: 5px 0;
      }
      
      input[type=range]::-webkit-slider-thumb {
        width: 18px;
        height: 18px;
      }
    }

    /* 評価エリア */
    #preference-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }
    #preference-controls label {
      width: 100%; 
      flex: none;
      display: flex;
      flex-direction: column;
      align-items: center; 
      font-weight: bold;
    }
    .pref-score-label {
      grid-column: 1 / -1;
      font-weight: bold;
    }

    /* ボタンエリア */
    #btn-area {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 10px;
    }
    .btn-row {
      display: flex;
      gap: 12px;
    }
    .saveBtn, .fileBtn {
      flex: 1;
      padding: 14px;
      font-size: 1em;
      font-weight: bold;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      text-align: center;
    }
    
    #saveFullBtn { background: rgb(137, 137, 137); }
    #saveGraphBtn { background: #444; }
    #exportDataBtn { background: rgb(183, 53, 109); }
    #importDataBtn { background: rgb(5, 123, 199); }

    @media (max-width: 600px) {
      .btn-row { flex-direction: column; }
      #controls { padding: 15px 10px; }
      .simple-grid input[type=range], #preference-controls input[type=range] {
          width: 75%;
          display: block;
          margin-left: auto;
          margin-right: auto;
      }
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="canvas-wrapper">
      <canvas id="graphCanvas" width="680" height="500"></canvas>
    </div>
    
    <div id="controls">
      <div class="input-group">
        <input id="reviewerInput" type="text" placeholder="レビュワー / Reviewer Name" maxlength="50" />
        <input id="textInput" type="text" placeholder="製品名など / Product Name" maxlength="100" />
        <input id="driverInput" type="text" placeholder="ドライバー構成 / Driver Info" maxlength="100" />
        
        <select id="presetSelect">
          <option value="" disabled selected>プリセットを選択 / Select Preset</option>
          <optgroup label="音のカタチ / Sound shape">
            <option value="flat">フラット / Flat, Neutral</option>
            <option value="vshape">弱ドンシャリ / Weak V-Shape</option>
            <option value="ultrav">ドンシャリ / V-Shape</option>
            <option value="narrow1">かまぼこ(中高域) / Narrow MHF</option>
            <option value="narrow2">かまぼこ(中低域) / Narrow MLF</option>
            <option value="basshead">低音特化 / BASS HEAD</option>
            <option value="trebleboost">高音特化 / Treble Boost</option>
          </optgroup>
          <optgroup label="温度・寒暖 / Temperature">
            <option value="temp-cool">寒色 / Cool (Warmth:0)</option>
            <option value="temp-scool">寒色寄り / Slightly Cool</option>
            <option value="temp-neutral">ニュートラル / Neutral</option>
            <option value="temp-swarm">暖色寄り / Slightly Warm</option>
            <option value="temp-warm">暖色 / Warm</option>
            <option value="temp-cw1">寒暖1 / Cool-Warm 1</option>
            <option value="temp-cw2">寒暖2 / Cool-Warm 2</option>
            <option value="temp-cw3">寒暖3 / Cool-Warm 3</option>
          </optgroup>
          <optgroup label="質感・ボケ / Texture & Blur">
            <option value="blur-zero">ボケなし / Sharp</option>
            <option value="blur-weak">ボケ微 / Slightly soft</option>
            <option value="blur-weak2">ボケ弱 / Little soft</option>
            <option value="blur-mid">ボケ中 / Middle soft</option>
            <option value="blur-strong">ボケ強 / Very Soft</option>
            <option value="blur-s-strong">ボケ特強 / Ultra soft</option>
            <option value="blur-max">ボケ最強 / Softest</option>
          </optgroup>
        </select>
      </div>
      
      <div id="extra-controls" class="control-box simple-grid">
        <label>全体レベル / Overall Lv
          <input type="range" id="overallLevel" min="0" max="10" value="5" />
          <span class="value" id="valOverall">5</span>
        </label>
        <label>高域レベル / High-Lv
          <input type="range" id="highLevel" min="0" max="10" value="10" />
          <span class="value" id="valHigh">10</span>
        </label>
        <label>低域レベル / Low-Lv
          <input type="range" id="lowLevel" min="0" max="10" value="10" />
          <span class="value" id="valLow">10</span>
        </label>

        <label style="border-top: 1px solid #ddd; padding-top: 10px; margin-top: 5px; flex-basis: 45%;">
          なだらかさ / Smoothness<br><span style="font-size:0.8em; font-weight:normal;">(Sharp &harr; Melted)</span>
          <input type="range" id="smoothnessSlider" min="0" max="5" value="0" step="1" />
          <span class="value" id="valSmoothness">0</span>
        </label>
        <label style="border-top: 1px solid #ddd; padding-top: 10px; margin-top: 5px; flex-basis: 45%;">
          粗さ / Roughness<br><span style="font-size:0.8em; font-weight:normal;">(Linear &harr; Steps)</span>
          <input type="range" id="roughnessSlider" min="0" max="5" value="0" />
          <span class="value" id="valRoughness">0</span>
        </label>
      </div>

      <div id="sliders-area"></div>

      <div id="stage-controls" class="control-box simple-grid">
        <label>音場の広さ / W
            <input type="range" id="stageWidth" min="1" max="5" value="3" />
            <span class="value" id="valStageWidth">3</span>
        </label>
        <label>音場の高さ / H
            <input type="range" id="stageHeight" min="1" max="5" value="3" />
            <span class="value" id="valStageHeight">3</span>
        </label>
        <label>音場の奥行 / D
            <input type="range" id="stageDepth" min="1" max="5" value="3" />
            <span class="value" id="valStageDepth">3</span>
        </label>
      </div>
      
      <div id="preference-controls" class="control-box">
        <label class="pref-score-label">得点 / Score (0= 隠す / Hide)
            <input type="range" id="score" min="0" max="100" value="80" />
            <span class="value" id="valScore">80</span>
        </label>
        <label>お気に入り度 / Fav
          <input type="range" id="favorite" min="0" max="5" value="3" />
          <span class="value" id="valFavorite">3</span>
        </label>
        <label>快適性・装着感 / Comfy
          <input type="range" id="comfort" min="0" max="5" value="3" />
          <span class="value" id="valComfort">3</span>
        </label>
        <label>コスパ / Value
          <input type="range" id="cost" min="0" max="5" value="3" />
          <span class="value" id="valCost">3</span>
        </label>
        <label>デザインの好み / Design
          <input type="range" id="design" min="0" max="5" value="3" />
          <span class="value" id="valDesign">3</span>
        </label>
      </div>
      
      <div id="btn-area">
        <div class="btn-row">
            <button id="saveGraphBtn" class="saveBtn">画像の保存 / IMG SAVE</button>
            <button id="saveFullBtn" class="saveBtn">全画面保存 / FULL IMG SAVE</button>
        </div>
        <div class="btn-row">
            <button id="exportDataBtn" class="fileBtn">設定保存 / DATA SAVE</button>
            <button id="importDataBtn" class="fileBtn" onclick="document.getElementById('fileInput').click()">設定読込 / DATA LOAD</button>
            <input type="file" id="fileInput" style="display: none;" accept=".json,.txt" />
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('graphCanvas');
      const ctx = canvas.getContext('2d');

      // スライダー配列定義
      const freqSliders = [], warmthSliders = [], softnessSliders = [], densitySliders = [];
      const bands = ['超高域 / UHF', '高域 / HF', '中高域 / MHF', '中域 / MF', '中低域 / MLF', '低域 / LF', '超低域 / ULF'];
      // デフォルト値
      const defaultFreq = [0, 3, 7, 10, 13, 17, 20];

      const slidersArea = document.getElementById('sliders-area');

      // パラメータグループの定義
      const paramGroups = [
        { label: '① 音域バランス / Level', arr: freqSliders, defaults: defaultFreq, min: 0, max: 20 },
        { label: '② 温度感 / Warmth', arr: warmthSliders, defaults: 10, min: 0, max: 20 },
        { label: '③ ボケの広さ / Blur Width', arr: softnessSliders, defaults: 0, min: 0, max: 20 },
        { label: '④ ボケの強さ / Blur Strength', arr: densitySliders, defaults: 20, min: 0, max: 20 }
      ];

      // グループごとにセクションを作成して配置
      paramGroups.forEach(group => {
        const section = document.createElement('div');
        section.className = 'param-section';
        const header = document.createElement('div');
        header.className = 'param-header';
        header.textContent = group.label;
        section.appendChild(header);
        const grid = document.createElement('div');
        grid.className = 'slider-grid';

        bands.forEach((bandName, i) => {
          const cell = document.createElement('div');
          cell.className = 'band-cell';
          const label = document.createElement('div');
          label.className = 'band-label';
          label.textContent = bandName;
          const slider = document.createElement('input');
          slider.type = 'range';
          slider.min = group.min;
          slider.max = group.max;
          slider.step = 1;
          let initVal = Array.isArray(group.defaults) ? group.defaults[i] : group.defaults;
          slider.value = initVal;
          const valSpan = document.createElement('span');
          valSpan.className = 'value';
          valSpan.textContent = initVal;
          slider.addEventListener('input', () => {
            valSpan.textContent = slider.value;
            draw();
          });
          cell.appendChild(label);
          cell.appendChild(slider);
          cell.appendChild(valSpan);
          grid.appendChild(cell);
          group.arr.push(slider);
        });
        section.appendChild(grid);
        slidersArea.appendChild(section);
      });

      // --- その他のスライダー定義 ---
      const overallSlider = document.getElementById('overallLevel');
      const highSlider = document.getElementById('highLevel');
      const lowSlider = document.getElementById('lowLevel');
      
      const smoothnessSlider = document.getElementById('smoothnessSlider');
      const roughnessSlider = document.getElementById('roughnessSlider');

      const stageW = document.getElementById('stageWidth');
      const stageH = document.getElementById('stageHeight');
      const stageD = document.getElementById('stageDepth');
      
      const valOverall = document.getElementById('valOverall');
      const valHigh = document.getElementById('valHigh');
      const valLow = document.getElementById('valLow');
      const valSmoothness = document.getElementById('valSmoothness');
      const valRoughness = document.getElementById('valRoughness');
      const valStageW = document.getElementById('valStageWidth');
      const valStageH = document.getElementById('valStageHeight');
      const valStageD = document.getElementById('valStageDepth');

      function updateExtraVals() {
        valOverall.textContent = overallSlider.value;
        valHigh.textContent = highSlider.value;
        valLow.textContent = lowSlider.value;
        valSmoothness.textContent = smoothnessSlider.value;
        valRoughness.textContent = roughnessSlider.value;
        valStageW.textContent = stageW.value;
        valStageH.textContent = stageH.value;
        valStageD.textContent = stageD.value;
      }

      [overallSlider, highSlider, lowSlider, smoothnessSlider, roughnessSlider, stageW, stageH, stageD].forEach(s => s.addEventListener('input', () => {
          updateExtraVals();
          draw();
      }));

      const reviewerInput = document.getElementById('reviewerInput');
      const textInput = document.getElementById('textInput');
      const driverInput = document.getElementById('driverInput');
      [reviewerInput, textInput, driverInput].forEach(el => el.addEventListener('input', draw));

      const scoreSlider = document.getElementById('score'), favSlider = document.getElementById('favorite'), comfortSlider = document.getElementById('comfort'), costSlider = document.getElementById('cost'), designSlider = document.getElementById('design');
      const valScore = document.getElementById('valScore'), valFav = document.getElementById('valFavorite'), valComfort = document.getElementById('valComfort'), valCost = document.getElementById('valCost'), valDesign = document.getElementById('valDesign');

      const prefSliders = [scoreSlider, favSlider, comfortSlider, costSlider, designSlider];
      const prefVals = [valScore, valFav, valComfort, valCost, valDesign];

      prefSliders.forEach((slider, idx) => {
        slider.addEventListener('input', () => {
          prefVals[idx].textContent = slider.value;
          draw();
        });
      });

      // --- プリセット処理 ---
      const presetSelect = document.getElementById('presetSelect');
      presetSelect.addEventListener('change', (e) => applyPreset(e.target.value));

      function applyPreset(type) {
          if (type.startsWith('blur-')) {
            let sVal = 0;
            switch(type) {
                case 'blur-zero': sVal = 0; break;
                case 'blur-weak': sVal = 1; break;
                case 'blur-weak2': sVal = 3; break;
                case 'blur-mid': sVal = 5; break;
                case 'blur-strong': sVal = 10; break;
                case 'blur-s-strong': sVal = 15; break;
                case 'blur-max': sVal = 20; break;
            }
            softnessSliders.forEach(s => { s.value = sVal; s.nextElementSibling.textContent = sVal; });
            densitySliders.forEach(s => { s.value = 20; s.nextElementSibling.textContent = 20; });
            draw();
            return;
          }

          if (type.startsWith('temp-')) {
            let wVals = [10, 10, 10, 10, 10, 10, 10];
            switch(type) {
                case 'temp-cool': wVals = [0, 0, 0, 0, 0, 0, 0]; break;
                case 'temp-scool': wVals = [5, 5, 5, 5, 5, 5, 5]; break;
                case 'temp-neutral': wVals = [10, 10, 10, 10, 10, 10, 10]; break;
                case 'temp-swarm': wVals = [15, 15, 15, 15, 15, 15, 15]; break;
                case 'temp-warm': wVals = [20, 20, 20, 20, 20, 20, 20]; break;
                case 'temp-cw1': wVals = [0, 2, 3, 5, 7, 9, 10]; break;
                case 'temp-cw2': wVals = [0, 3, 6, 10, 13, 16, 20]; break;
                case 'temp-cw3': wVals = [10, 11, 12, 14, 16, 18, 20]; break;
            }
            warmthSliders.forEach((s, i) => { s.value = wVals[i]; s.nextElementSibling.textContent = s.value; });
            draw();
            return;
          }

          let newFreq = [...defaultFreq], newOverall = 5, newHigh = 10, newLow = 10;
          switch(type) {
              case 'flat': newFreq = [0, 3, 7, 10, 13, 17, 20]; break;
              case 'vshape': newFreq = [0, 1, 3, 6, 10, 15, 20]; break;
              case 'ultrav': newFreq = [0, 1, 2, 3, 5, 11, 20]; break;
              case 'narrow1': newFreq = [2, 10, 15, 18, 19, 19, 16]; break;
			  case 'narrow2': newFreq = [2, 8, 13, 17, 19, 19, 15]; break;
              case 'basshead': newOverall = 6; newHigh = 7; newFreq = [0, 4, 10, 14, 18, 20, 20]; break;
              case 'trebleboost': newOverall = 6; newLow = 3; break;
          }
          freqSliders.forEach((s, i) => { s.value = newFreq[i]; s.nextElementSibling.textContent = s.value; });
          overallSlider.value = newOverall; highSlider.value = newHigh; lowSlider.value = newLow;
          updateExtraVals(); draw();
      }

      // --- 描画ロジック ---
      function getRGB(warmth) {
        const ratio = warmth / 20; 
        return {
          r: Math.round(0 + 242 * ratio),
          g: Math.round(145 + (13 - 145) * ratio),
          b: Math.round(242 + (94 - 242) * ratio)
        };
      }

      function drawBackground(centerX, baseY, triHeight, baseX) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ccc';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1;
        for (let i = 1; i <= 10; i++) {
          const scale = i / 10;
          const topY = baseY + triHeight - triHeight * scale;
          ctx.beginPath();
          ctx.moveTo(centerX, topY); 
          ctx.lineTo(centerX - baseX * scale, baseY + triHeight);
          ctx.lineTo(centerX + baseX * scale, baseY + triHeight);
          ctx.closePath();
          ctx.stroke();
        }
        ctx.fillStyle = '#000';
        ctx.font = 'bold 28px Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle'; // ★常に下にズレた位置（middle基準）で描画
        ctx.fillText('High', centerX, baseY - 30);
        ctx.fillText('Low', centerX - baseX - 20, 432);
        ctx.fillText('Low', centerX + baseX + 20, 432);
      }

      /**
       * ★ リニアスムース・パス生成ロジック (UI反転対応)
       */
      function generatePathPoints(points, roughnessVal, smoothnessVal) {
          if (points.length < 2) return [];
          
          let rawPath = [];
          
          const rVal = parseInt(roughnessVal);
          
          if (rVal === 0) {
              rawPath = points; 
          } else {
              let steps;
              switch(rVal) {
                  case 1: steps = 12; break; 
                  case 2: steps = 8; break;
                  case 3: steps = 4; break;
                  case 4: steps = 2; break;
                  case 5: steps = 1; break; 
              }

              let currentX = points[0].x;
              let currentY = points[0].y;
              rawPath.push({x: currentX, y: currentY});

              for (let i = 0; i < points.length - 1; i++) {
                  const pStart = points[i];
                  const pEnd = points[i+1];
                  for (let j = 1; j <= steps; j++) {
                      const t = j / steps;
                      const targetX = pStart.x + (pEnd.x - pStart.x) * t;
                      const targetY = pStart.y + (pEnd.y - pStart.y) * t;
                      const midX = (currentX + targetX) / 2;
                      rawPath.push({x: midX, y: currentY}); 
                      rawPath.push({x: midX, y: targetY});  
                      rawPath.push({x: targetX, y: targetY}); 
                      currentX = targetX;
                      currentY = targetY;
                  }
              }
          }

          if (smoothnessVal <= 0) return rawPath; 

          // Phase 2: Chaikin Smoothing (固定回数)
          const fixedIterations = 4;
          const maxRatio = 0.5; 
          const ratio = (smoothnessVal / 5.0) * maxRatio;

          let refinedPath = rawPath;
          for (let k = 0; k < fixedIterations; k++) {
              refinedPath = variableChaikinSmooth(refinedPath, ratio);
          }
          
          // Phase 3: Liquid Averaging (移動平均フィルタ)
          if (smoothnessVal > 0) {
             let smoothPasses = Math.floor(Math.pow(smoothnessVal, 2.5) * 1.5); 
             for(let m=0; m < smoothPasses; m++) {
                 refinedPath = applyCoordinateAveraging(refinedPath);
             }
          }

          return refinedPath;
      }

      function variableChaikinSmooth(path, ratio) {
          if (path.length < 2) return path;
          const newPath = [];
          newPath.push(path[0]); 
          for (let i = 0; i < path.length - 1; i++) {
              const p0 = path[i];
              const p1 = path[i+1];
              newPath.push({
                  x: (1 - ratio) * p0.x + ratio * p1.x,
                  y: (1 - ratio) * p0.y + ratio * p1.y
              });
              newPath.push({
                  x: ratio * p0.x + (1 - ratio) * p1.x,
                  y: ratio * p0.y + (1 - ratio) * p1.y
              });
          }
          newPath.push(path[path.length - 1]);
          return newPath;
      }
      
      function applyCoordinateAveraging(arr) {
          if (arr.length < 3) return arr;
          const newArr = [];
          newArr.push(arr[0]); 
          for (let i = 1; i < arr.length - 1; i++) {
              const prev = arr[i - 1];
              const curr = arr[i];
              const next = arr[i + 1];
              newArr.push({
                  x: (prev.x + curr.x + next.x) / 3,
                  y: (prev.y + curr.y + next.y) / 3
              });
          }
          newArr.push(arr[arr.length - 1]); 
          return newArr;
      }

      function drawCube(ctx, cx, cy, wVal, hVal, dVal, isWireframe) {
         const step = 18; 
         const w = wVal * step, h = hVal * step, d = dVal * step; 
         const angle = Math.PI / 4, depthScale = 0.6; 
         
         const totalDx = d * Math.cos(angle) * depthScale;
         const totalDy = -d * Math.sin(angle) * depthScale;
         
         const xStart = cx - (w / 2) - (totalDx / 2);
         const yStart = cy + (h / 2) - (totalDy / 2);

         const pFrontBL = { x: xStart, y: yStart };
         const pFrontBR = { x: xStart + w, y: yStart };
         const pFrontTR = { x: xStart + w, y: yStart - h };
         const pFrontTL = { x: xStart, y: yStart - h };
         
         const pBackBL = { x: xStart + totalDx, y: yStart + totalDy };
         const pBackBR = { x: xStart + w + totalDx, y: yStart + totalDy };
         const pBackTR = { x: xStart + w + totalDx, y: yStart - h + totalDy };
         const pBackTL = { x: xStart + totalDx, y: yStart - h + totalDy };

         ctx.save();
         ctx.lineJoin = 'round';
         if (isWireframe) {
            ctx.lineWidth = 1; ctx.strokeStyle = '#222'; ctx.setLineDash([2, 2]);
            ctx.beginPath();
            ctx.moveTo(pFrontBL.x, pFrontBL.y); ctx.lineTo(pFrontBR.x, pFrontBR.y); ctx.lineTo(pFrontTR.x, pFrontTR.y); ctx.lineTo(pFrontTL.x, pFrontTL.y); ctx.closePath();
            ctx.moveTo(pBackBL.x, pBackBL.y); ctx.lineTo(pBackBR.x, pBackBR.y); ctx.lineTo(pBackTR.x, pBackTR.y); ctx.lineTo(pBackTL.x, pBackTL.y); ctx.closePath();
            ctx.moveTo(pFrontBL.x, pFrontBL.y); ctx.lineTo(pBackBL.x, pBackBL.y); ctx.moveTo(pFrontBR.x, pFrontBR.y); ctx.lineTo(pBackBR.x, pBackBR.y);
            ctx.moveTo(pFrontTR.x, pFrontTR.y); ctx.lineTo(pBackTR.x, pBackTR.y); ctx.moveTo(pFrontTL.x, pFrontTL.y); ctx.lineTo(pBackTL.x, pBackTL.y);
            ctx.stroke();
         } else {
            ctx.lineWidth = 1; ctx.strokeStyle = '#222'; ctx.setLineDash([]);
            // Top
            ctx.fillStyle = '#eee'; ctx.beginPath(); ctx.moveTo(pFrontTL.x, pFrontTL.y); ctx.lineTo(pFrontTR.x, pFrontTR.y); ctx.lineTo(pBackTR.x, pBackTR.y); ctx.lineTo(pBackTL.x, pBackTL.y); ctx.closePath(); ctx.fill(); ctx.stroke();
            // Right
            ctx.fillStyle = '#999'; ctx.beginPath(); ctx.moveTo(pFrontTR.x, pFrontTR.y); ctx.lineTo(pFrontBR.x, pFrontBR.y); ctx.lineTo(pBackBR.x, pBackBR.y); ctx.lineTo(pBackTR.x, pBackTR.y); ctx.closePath(); ctx.fill(); ctx.stroke();
            // Front
            ctx.fillStyle = '#bbb'; ctx.beginPath(); ctx.moveTo(pFrontBL.x, pFrontBL.y); ctx.lineTo(pFrontBR.x, pFrontBR.y); ctx.lineTo(pFrontTR.x, pFrontTR.y); ctx.lineTo(pFrontTL.x, pFrontTL.y); ctx.closePath(); ctx.fill(); ctx.stroke();
         }
         ctx.restore();
      }

      function draw() {
        const centerX = 340, baseY = 60, baseX = 200, triHeight = Math.sqrt(3) * baseX;
        const overallScale = overallSlider.value / 10, verticalScale = highSlider.value / 10, horizontalScale = lowSlider.value / 10;
        
        const rawSmoothness = parseFloat(smoothnessSlider.value);
        const rawRoughness = parseInt(roughnessSlider.value);
        
        drawBackground(centerX, baseY, triHeight, baseX);

        // タイトルなど
        ctx.save();
        ctx.fillStyle = '#222'; ctx.font = 'bold 28px Arial, sans-serif'; ctx.textAlign = 'left'; ctx.textBaseline = 'top';
        ctx.fillText('Timbre', 20, 20); ctx.fillText('Impression', 20, 52); ctx.fillText('Chart', 20, 84);
        
        // Reviewerエリア (タイトルの下)
        const rName = reviewerInput.value.trim();
        const revStartY = 130; 
        
        if (rName) {
            ctx.fillStyle = '#666'; ctx.font = 'bold 18px Arial, sans-serif'; ctx.textAlign = 'left';
            ctx.fillText('Reviewer', 20, revStartY);
            
            let rSize = 28;
            ctx.font = `bold ${rSize}px Arial, sans-serif`;
            ctx.fillStyle = '#222';
            const maxW = 200; 
            while (ctx.measureText(rName).width > maxW && rSize > 12) {
                rSize--;
                ctx.font = `bold ${rSize}px Arial, sans-serif`;
            }
            ctx.fillText(rName, 20, revStartY + 22);
        }
        ctx.restore();

        // 中央下 Driver Info
        const dText = driverInput.value.trim();
        if(dText) {
             ctx.save();
             ctx.fillStyle = '#444'; ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
             const driverY = 440; 
             let dSize = 24; ctx.font = `bold ${dSize}px Arial, sans-serif`;
             while (ctx.measureText(dText).width > 220 && dSize > 10) { dSize--; ctx.font = `bold ${dSize}px Arial, sans-serif`; }
             ctx.fillText(dText, centerX, driverY);
             ctx.restore();
        }

        // Stageエリア
        const stageOriginY = 320, stageOriginX = 90; 
        ctx.save();
        ctx.fillStyle = '#222'; ctx.font = 'bold 28px Arial, sans-serif'; ctx.textAlign = 'center';
        ctx.textBaseline = 'middle'; // ★ここもmiddleにして位置ズレを防止
        ctx.fillText('Stage', stageOriginX, stageOriginY - 100); 
        ctx.restore();
        drawCube(ctx, stageOriginX, stageOriginY, parseInt(stageW.value), parseInt(stageH.value), parseInt(stageD.value), false);
        drawCube(ctx, stageOriginX, stageOriginY, 5, 5, 5, true);

        // SCORE / Icons
        const rx = canvas.width - 20;
        const scoreVal = parseInt(scoreSlider.value);
        
        if (scoreVal > 0) {
            ctx.save(); ctx.textAlign = 'right'; ctx.textBaseline = 'top'; 
            ctx.fillStyle = '#222'; ctx.font = 'bold 24px Arial, sans-serif'; 
            ctx.fillText('SCORE', rx, 20);
            const scoreLabelWidth = ctx.measureText('SCORE').width;
            ctx.font = `bold 72px Arial, sans-serif`; 
            ctx.fillText(scoreVal, rx, 48); 
            ctx.restore();
        }
        
        ctx.save(); ctx.textAlign = 'right'; ctx.textBaseline = 'alphabetic'; 
        // ★ 変更点: SCOREが0なら上(20)へ、あれば下(130)へ
        const iconStartY = (scoreVal > 0) ? 130 : 20; 
        const iconHeight = 65; 
        const drawStat = (label, mark, val, y) => {
           ctx.font = '28px sans-serif'; ctx.fillStyle = '#000';
           let s = ""; for(let k=0; k<val; k++) s += mark;
           ctx.fillText(s, rx, y + 18);
           ctx.font = 'bold 18px Arial, sans-serif'; ctx.fillStyle = '#666'; ctx.fillText(label, rx, y + 40);
        };
        drawStat('Favorite', '★', parseInt(favSlider.value), iconStartY);
        drawStat('Comfortable', '●', parseInt(comfortSlider.value), iconStartY + iconHeight);
        drawStat('Value', '◆', parseInt(costSlider.value), iconStartY + iconHeight * 2);
        drawStat('Design', '❤', parseInt(designSlider.value), iconStartY + iconHeight * 3);
        ctx.restore();

        // メイングラフデータ計算
        const pL = [], rgbs = [], dens = [], softs = [];
        
        for (let i = 0; i < bands.length; i++) {
            const freq = parseInt(freqSliders[i].value) / 20; 
            const y0 = baseY + (triHeight * i / (bands.length - 1));
            const y = baseY + triHeight - (baseY + triHeight - y0) * verticalScale * overallScale;
            const xOff = baseX * freq * horizontalScale * overallScale;
            
            pL.push({ x: centerX - xOff, y }); 
            
            rgbs.push(getRGB(parseInt(warmthSliders[i].value)));
            dens.push(parseInt(densitySliders[i].value)); 
            softs.push(parseInt(softnessSliders[i].value));
        }

        const createSymmetricPath = (basePoints, rVal, sVal) => {
            ctx.beginPath();
            const leftPath = generatePathPoints(basePoints, rVal, sVal);
            if(leftPath.length === 0) return;

            ctx.moveTo(centerX, basePoints[0].y);
            leftPath.forEach(p => ctx.lineTo(p.x, p.y));
            
            const lastP = basePoints[basePoints.length - 1];
            ctx.lineTo(centerX, lastP.y);
            
            for (let i = leftPath.length - 1; i >= 0; i--) {
                const p = leftPath[i];
                const mirroredX = centerX + (centerX - p.x);
                ctx.lineTo(mirroredX, p.y);
            }
            ctx.closePath();
        };

        if (softs.some(v => v > 0)) {
            ctx.save();
            const pL_blur = pL.map((p, i) => ({ x: p.x - softs[i] * 3.5, y: p.y }));
            createSymmetricPath(pL_blur, rawRoughness, rawSmoothness);
            ctx.filter = `blur(${5 + Math.max(...softs)}px)`;
            const gB = ctx.createLinearGradient(0, pL[0].y, 0, pL[pL.length-1].y);
            bands.forEach((_, i) => gB.addColorStop(i/(bands.length-1), `rgba(${rgbs[i].r},${rgbs[i].g},${rgbs[i].b},${dens[i]/20})`));
            ctx.fillStyle = gB; 
            ctx.fill(); 
            ctx.restore();
        }

        ctx.save();
        createSymmetricPath(pL, rawRoughness, rawSmoothness);
        const gM = ctx.createLinearGradient(0, pL[0].y, 0, pL[pL.length-1].y);
        bands.forEach((_, i) => gM.addColorStop(i/(bands.length-1), `rgba(${rgbs[i].r},${rgbs[i].g},${rgbs[i].b},0.9)`));
        ctx.fillStyle = gM; 
        ctx.fill(); 
        ctx.restore();

        // Product Name (Bottom)
        const bH = 45;
        ctx.fillStyle = '#000';
        ctx.fillRect(0, canvas.height - bH, canvas.width, bH);
        const txt = textInput.value.trim();
        if (txt) {
          ctx.save(); // ★状態保存して他の描画への影響を防ぐ
          ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          let fs = 32; ctx.font = `bold ${fs}px Arial, sans-serif`;
          while (ctx.measureText(txt).width > canvas.width * 0.9 && fs > 12) { fs--; ctx.font = `bold ${fs}px Arial, sans-serif`; }
          ctx.fillText(txt, centerX, canvas.height - (bH / 2) + 2);
          ctx.restore(); // ★状態復元
        }
      }

      draw();
      
      document.getElementById('saveGraphBtn').addEventListener('click', () => { const a = document.createElement('a'); a.download = 'TIC_Graph.png'; a.href = canvas.toDataURL(); a.click(); });
      document.getElementById('saveFullBtn').addEventListener('click', () => {
        const w = document.getElementById('canvas-wrapper'), op = w.style.position;
        w.style.position = 'static'; window.scrollTo(0,0);
        html2canvas(document.getElementById('container'), { scale: 2, backgroundColor: "#fff", scrollY: 0, ignoreElements: el => el.id === 'btn-area' }).then(c => {
            const a = document.createElement('a'); a.download = 'TIC_Full_Review.png'; a.href = c.toDataURL(); a.click(); w.style.position = op;
        });
      });
      document.getElementById('exportDataBtn').addEventListener('click', () => {
          const d = { 
              reviewer: reviewerInput.value, text: textInput.value, driver: driverInput.value, 
              overall: overallSlider.value, high: highSlider.value, low: lowSlider.value, 
              smoothness: smoothnessSlider.value, roughness: roughnessSlider.value, 
              stage: { w: stageW.value, h: stageH.value, d: stageD.value }, 
              pref: { score: scoreSlider.value, fav: favSlider.value, comfort: comfortSlider.value, cost: costSlider.value, design: designSlider.value }, 
              freqs: freqSliders.map(s => s.value), warmth: warmthSliders.map(s => s.value), softness: softnessSliders.map(s => s.value), density: densitySliders.map(s => s.value) 
          };
          const u = URL.createObjectURL(new Blob([JSON.stringify(d, null, 2)], {type: "application/json"}));
          const a = document.createElement('a'); a.download = "TIC_Settings.json"; a.href = u; a.click(); URL.revokeObjectURL(u);
      });
      document.getElementById('fileInput').addEventListener('change', e => {
          const f = e.target.files[0]; if(!f) return;
          const r = new FileReader();
          r.onload = ev => {
              try {
                  const d = JSON.parse(ev.target.result);
                  if(d.reviewer!==undefined) reviewerInput.value=d.reviewer;
                  if(d.text!==undefined) textInput.value=d.text; if(d.driver!==undefined) driverInput.value=d.driver;
                  if(d.overall!==undefined) overallSlider.value=d.overall; if(d.high!==undefined) highSlider.value=d.high; if(d.low!==undefined) lowSlider.value=d.low;
                  if(d.smoothness!==undefined) smoothnessSlider.value=d.smoothness; 
                  if(d.roughness!==undefined) roughnessSlider.value=d.roughness;
                  if(d.stage) { stageW.value=d.stage.w; stageH.value=d.stage.h; stageD.value=d.stage.d; }
                  if(d.pref) { scoreSlider.value=d.pref.score; favSlider.value=d.pref.fav; comfortSlider.value=d.pref.comfort; costSlider.value=d.pref.cost; designSlider.value=d.pref.design; }
                  if(d.freqs) freqSliders.forEach((s,i)=>{if(d.freqs[i]!==undefined)s.value=d.freqs[i]});
                  if(d.warmth) warmthSliders.forEach((s,i)=>{if(d.warmth[i]!==undefined)s.value=d.warmth[i]});
                  if(d.softness) softnessSliders.forEach((s,i)=>{if(d.softness[i]!==undefined)s.value=d.softness[i]});
                  if(d.density) densitySliders.forEach((s,i)=>{if(d.density[i]!==undefined)s.value=d.density[i]});
                  updateExtraVals(); 
                  [...freqSliders, ...warmthSliders, ...softnessSliders, ...densitySliders].forEach(s => s.nextElementSibling.textContent = s.value);
                  prefSliders.forEach(s => s.nextElementSibling.textContent = s.value);
                  draw();
              } catch(err) { alert("Error: " + err); }
          };
          r.readAsText(f); e.target.value = '';
      });
    })();
  </script>
</body>
</html>
